# 微调介绍

>   微调是深度学习中迁移学习的一种形式。它采用预训练模型，且该模型已在大型数据集上训练过，用于自然语言处理或图像识别等通用任务,对其部分参数进行微调，使其在某一专业领域具有更好的效果,而无需从头开始训练。

## 应用场景

### 适用场景
+ **任务特定性：** 当任务具有明确的目标和结构时，如情感分析、文本分类、命名实体识别等，微调能够让预训练模型更好地适应这些特定任务。
+ **有限的标注数据：** 即使只有少量的标注数据，微调也能通过调整预训练模型的参数来提升模型在特定任务上的性能。
+ **需求高准确率：** 对于需要高度准确性的任务，微调可以通过细致调整模型以适应特定数据集的特点，从而提高准确率。
+ **计算资源限制：** 相对于从头训练模型，微调需要的计算资源较少，适合计算资源受限的情况。

### 不适用场景
+ **时序数据高频更新的场景：** 当任务的数据分布和特点经常变化时，微调可能无法适应这种变化。
+ **大规模数据集：** 当任务的数据集规模非常大时，微调可能无法充分利用这些数据，从而无法发挥其优势。
+ **任务特定性不强：** 当任务的目标和结构不明确时，微调可能无法有效提升模型性能。
+ **需求高泛化性：** 对于需要高泛化性的任务，微调可能无法满足这一需求。
+ **场景数据过少：** 当任务的数据集规模非常小时，微调可能无法充分利用这些数据，从而无法发挥其优势。

## 为什么要使用微调？

+ **资源利用最大化：** 通过微调，可以充分利用现有的预训练模型和其在广泛数据上学到的知识，避免了重复进行昂贵的预训练过程，从而实现资源的高效利用。
+ **计算效率：** 微调一个预训练模型通常需要更少的计算资源和时间。这是因为预训练模型已经学习了大量的通用知识，只需要较小的调整即可适应新任务。
+ **性能优化：** 微调可以进一步优化模型的性能，提高其在特定任务上的准确性、效率和鲁棒性。
+ **泛化能力：** 即使是小规模的数据集，通过微调，模型也能学习到足够的任务特定知识，从而在新样本上表现良好。

## 基础知识

### 核心库组件
+ **Transformers：** 核心库、模型加载、模型训练、模型评估、模型部署
+ **Tokenizers：** 分词器、词向量、词嵌入、词表
+ **Datasets：** 模型加载、模型训练、模型评估、模型部署
+ **Evaluate：** 评估函数、提供各种评估指标的计算函数
+ **PFFT：** 高效模型微调库，支持多种微调方法 
+ **Accelerate：** 分布式训练、混合精度训练、多卡训练、多机训练、提供了分布式模型训练推理解决方案

+ **PyTorch：** 模型加载、模型训练、模型评估、模型部署
+ **TensorFlow：** 模型加载、模型训练、模型评估、模型部署
+ **Keras：** 模型加载、模型训练、模型评估、模型部署
+ **NLP：** 文本分类、情感分析、命名实体识别、文本生成、机器翻译
+ **CV：** 图像分类、目标检测、图像生成、图像分割
+ **MLOps：** 模型训练、模型评估、模型部署、模型监控
+ **AutoML：** 模型搜索、超参数优化、模型选择、模型融合

### 核心方法
+ **模型评估：** 准确率、精确率、召回率、F1值、AUC值、混淆矩阵
+ **模型部署：** 本地部署、云端部署、边缘部署、移动端部署
+ **模型监控：** 模型性能、模型健康、模型可解释性、模型鲁棒性
+ **模型融合：** 模型集成、模型融合、模型蒸馏、模型剪枝
+ **模型搜索：** 超参数搜索、架构搜索、模型搜索、模型选择
+ **超参数优化：** 网格搜索、随机搜索、贝叶斯优化、进化算法
+ **模型选择：** 模型评估、模型选择、模型融合、模型蒸馏
+ **模型融合：** 模型集成、模型融合、模型蒸馏、模型剪枝



## 微调的步骤

### 1. 选择预训练模型

选择一个在大规模数据集上训练过的预训练模型，如BERT、GPT、ResNet等。选择的预训练模型应该与任务的特点相匹配，如BERT适用于文本任务，ResNet适用于图像任务。

### 2. 准备数据集
 定义数据加载器


### 3. 构建模型


### 4. 定义损失函数

### 5. 定义优化器


### 6. 训练模型


### 7. 评估模型


### 8. 部署模型



## 微调方法

| 微调方法       | 参数调整范围          | 资源效率     | 适用性                                                         | 潜在性能影响         | 特点                   | 明确优点                                            | 缺点                                | 注意事项                               |
|--------------|---------------------|------------|--------------------------------------------------------------|---------------------|----------------------|--------------------------------------------------|------------------------------------|----------------------------------------|
| Prompt Tuning| 仅限输入提示参数       | 高         | NLP任务，如分类、问答、文本生成，尤其适合大型语言模型             | 可能需要大量样本     | 无需调整原始模型参数     | - 无需修改模型参数，减小模型尺寸           | - 需要大量样本用于学习提示              | - 提示的设计对性能影响重大，需要谨慎选择       |
| P-Tuning     | 任务特定的提示参数     | 中到高     | NLP任务，包括但不限于实体识别、情感分析、文本摘要                 | 取决于训练样本量     | 引入可学习的连续嵌入作为提示 | - 相对于全参数微调更高效                 | - 样本不足时可能效果有限                | - 提示设计和样本多样性对性能有影响          |
| Prefix-Tuning| 解码器前缀参数        | 中         | 序列生成任务，如文本生成、机器翻译、代码生成                       | 可能稍逊于全参数微调 | 在解码步骤前添加可学习的前缀 | - 节省计算资源，适用于序列生成任务         | - 生成质量可能不如全参数微调            | - 前缀的设计需要考虑生成任务的特点           |
| LoRA         | 低秩矩阵参数          | 高         | 广泛应用于NLP和视觉任务，如图像分类、对象检测、语言理解和生成        | 微小到中等的性能损失 | 通过添加低秩矩阵调整权重   | - 高效降低模型参数数量，保持性能           | - 需要仔细的超参数调整                | - 低秩矩阵的维度和超参数的选择非常重要       |
| QLoRA        | 量化的低秩矩阵参数     | 非常高     | 资源受限环境，如移动设备和嵌入式系统，适用于NLP和视觉任务          | 可能有精度损失       | 引入量化技术进一步减少参数 | - 极大地减小模型大小和计算需求             | - 量化可能导致精度损失，需要权衡       | - 量化方法的选择和位宽需要小心考虑           |
| AdaLoRA      | 动态调整的低秩矩阵参数 | 中到高     | 多任务学习、持续学习、场景适应，适用于需要模型动态适应不同任务的场景 | 取决于调整策略       | 动态调整低秩矩阵的更新   | - 适应不同任务的动态性能调整               | - 需要精心设计调整策略               | - 调整策略的设计和样本多样性对性能有影响     |



## 微调的注意事项

+ RLHF (Reinforcement Learning from Human Feedback)
